/* Generated by Opal 1.2.0 */
Opal.modules["securerandom"] = function(Opal) {
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$, $$ = Opal.$$, $module = Opal.module;

  Opal.add_stubs(['$extend', '$warn', '$rand', '$gen_random', '$_verify_count', '$encode']);
  return (function($base, $parent_nesting) {
    var self = $module($base, 'SecureRandom');

    var $nesting = [self].concat($parent_nesting), $SecureRandom_bytes$1, $SecureRandom_gen_random$2;

    
    self.$extend($$$($$($nesting, 'Random'), 'Formatter'));
    
    var gen_random_bytes;

    if ((Opal.global.crypto   && Opal.global.crypto.getRandomValues) ||
        (Opal.global.msCrypto && Opal.global.msCrypto.getRandomValues)) {
      // This method is available in all non-ancient web browsers.

      var crypto = Opal.global.crypto || Opal.global.msCrypto;
      gen_random_bytes = function(count) {
        var storage = new Uint8Array(count);
        crypto.getRandomValues(storage);
        return storage;
      };
    }
    else if (Opal.global.crypto && Opal.global.crypto.randomBytes) {
      // This method is available in Node.js

      gen_random_bytes = function(count) {
        return Opal.global.crypto.randomBytes(count);
      };
    }
    else {
      // Let's dangerously polyfill this interface with our MersenneTwister
      // xor native JS Math.random xor something about current time...
      // That's hardly secure, but the following warning should provide a person
      // deploying the code a good idea on what he should do to make his deployment
      // actually secure.
      // It's possible to interface other libraries by adding an else if above if
      // that's really desired.

      self.$warn("" + "Can't get a Crypto.getRandomValues interface or Crypto.randomBytes." + "The random values generated with SecureRandom won't be " + "cryptographically secure")

      gen_random_bytes = function(count) {
        var storage = new Uint8Array(count);
        for (var i = 0; i < count; i++) {
          storage[i] = self.$rand(255) ^ Math.floor(Math.random() * 256);
          storage[i] ^= +(new Date())>>self.$rand(255)&0xff;
        }
        return storage;
      }
    }
  ;
    Opal.defs(self, '$bytes', $SecureRandom_bytes$1 = function $$bytes(bytes) {
      var self = this;

      
      
      if (bytes == null) {
        bytes = nil;
      };
      return self.$gen_random(bytes);
    }, $SecureRandom_bytes$1.$$arity = -1);
    return (Opal.defs(self, '$gen_random', $SecureRandom_gen_random$2 = function $$gen_random(count) {
      var self = this, out = nil;

      
      
      if (count == null) {
        count = nil;
      };
      count = $$($nesting, 'Random').$_verify_count(count);
      out = "";
      
      var bytes = gen_random_bytes(count);
      for (var i = 0; i < count; i++) {
        out += String.fromCharCode(bytes[i]);
      }
    ;
      return out.$encode("ASCII-8BIT");
    }, $SecureRandom_gen_random$2.$$arity = -1), nil) && 'gen_random';
  })($nesting[0], $nesting)
};
