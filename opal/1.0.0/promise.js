/* Generated by Opal 1.0.0 */
Opal.modules["promise"] = function(Opal) {
  function $rb_plus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs + rhs : lhs['$+'](rhs);
  }
  function $rb_le(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs <= rhs : lhs['$<='](rhs);
  }
  function $rb_minus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs - rhs : lhs['$-'](rhs);
  }
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.const_get_qualified, $$ = Opal.const_get_relative, $breaker = Opal.breaker, $slice = Opal.slice, $klass = Opal.klass, $hash2 = Opal.hash2, $truthy = Opal.truthy, $send = Opal.send;

  Opal.add_stubs(['$resolve', '$new', '$reject', '$attr_reader', '$===', '$value', '$key?', '$keys', '$!=', '$==', '$<<', '$>>', '$exception?', '$[]', '$resolved?', '$rejected?', '$!', '$error', '$include?', '$action', '$realized?', '$raise', '$^', '$call', '$resolve!', '$exception!', '$any?', '$each', '$reject!', '$there_can_be_only_one!', '$then', '$to_proc', '$fail', '$always', '$trace', '$class', '$object_id', '$+', '$inspect', '$act?', '$nil?', '$prev', '$push', '$concat', '$it', '$proc', '$reverse', '$pop', '$<=', '$length', '$shift', '$-', '$wait', '$map', '$reduce', '$try', '$tap', '$all?', '$find']);
  return (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Promise');

    var $nesting = [self].concat($parent_nesting), $Promise_value$1, $Promise_error$2, $Promise_when$3, $Promise_initialize$4, $Promise_value$5, $Promise_act$ques$6, $Promise_action$7, $Promise_exception$ques$8, $Promise_realized$ques$9, $Promise_resolved$ques$10, $Promise_rejected$ques$11, $Promise_$$12, $Promise_$lt$lt$13, $Promise_$gt$gt$14, $Promise_resolve$15, $Promise_resolve$excl$16, $Promise_reject$18, $Promise_reject$excl$19, $Promise_exception$excl$21, $Promise_then$22, $Promise_then$excl$23, $Promise_fail$24, $Promise_fail$excl$25, $Promise_always$26, $Promise_always$excl$27, $Promise_trace$28, $Promise_trace$excl$29, $Promise_there_can_be_only_one$excl$30, $Promise_inspect$31;

    self.$$prototype.value = self.$$prototype.action = self.$$prototype.exception = self.$$prototype.realized = self.$$prototype.next = self.$$prototype.delayed = self.$$prototype.error = self.$$prototype.prev = nil;
    
    Opal.defs(self, '$value', $Promise_value$1 = function $$value(value) {
      var self = this;

      return self.$new().$resolve(value)
    }, $Promise_value$1.$$arity = 1);
    Opal.defs(self, '$error', $Promise_error$2 = function $$error(value) {
      var self = this;

      return self.$new().$reject(value)
    }, $Promise_error$2.$$arity = 1);
    Opal.defs(self, '$when', $Promise_when$3 = function $$when($a) {
      var $post_args, promises, self = this;

      
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      
      promises = $post_args;;
      return $$($nesting, 'When').$new(promises);
    }, $Promise_when$3.$$arity = -1);
    self.$attr_reader("error", "prev", "next");
    
    Opal.def(self, '$initialize', $Promise_initialize$4 = function $$initialize(action) {
      var self = this;

      
      
      if (action == null) {
        action = $hash2([], {});
      };
      self.action = action;
      self.realized = false;
      self.exception = false;
      self.value = nil;
      self.error = nil;
      self.delayed = false;
      self.prev = nil;
      return (self.next = []);
    }, $Promise_initialize$4.$$arity = -1);
    
    Opal.def(self, '$value', $Promise_value$5 = function $$value() {
      var self = this;

      if ($truthy($$($nesting, 'Promise')['$==='](self.value))) {
        return self.value.$value()
      } else {
        return self.value
      }
    }, $Promise_value$5.$$arity = 0);
    
    Opal.def(self, '$act?', $Promise_act$ques$6 = function() {
      var $a, self = this;

      return ($truthy($a = self.action['$key?']("success")) ? $a : self.action['$key?']("always"))
    }, $Promise_act$ques$6.$$arity = 0);
    
    Opal.def(self, '$action', $Promise_action$7 = function $$action() {
      var self = this;

      return self.action.$keys()
    }, $Promise_action$7.$$arity = 0);
    
    Opal.def(self, '$exception?', $Promise_exception$ques$8 = function() {
      var self = this;

      return self.exception
    }, $Promise_exception$ques$8.$$arity = 0);
    
    Opal.def(self, '$realized?', $Promise_realized$ques$9 = function() {
      var self = this;

      return self.realized['$!='](false)
    }, $Promise_realized$ques$9.$$arity = 0);
    
    Opal.def(self, '$resolved?', $Promise_resolved$ques$10 = function() {
      var self = this;

      return self.realized['$==']("resolve")
    }, $Promise_resolved$ques$10.$$arity = 0);
    
    Opal.def(self, '$rejected?', $Promise_rejected$ques$11 = function() {
      var self = this;

      return self.realized['$==']("reject")
    }, $Promise_rejected$ques$11.$$arity = 0);
    
    Opal.def(self, '$^', $Promise_$$12 = function(promise) {
      var self = this;

      
      promise['$<<'](self);
      self['$>>'](promise);
      return promise;
    }, $Promise_$$12.$$arity = 1);
    
    Opal.def(self, '$<<', $Promise_$lt$lt$13 = function(promise) {
      var self = this;

      
      self.prev = promise;
      return self;
    }, $Promise_$lt$lt$13.$$arity = 1);
    
    Opal.def(self, '$>>', $Promise_$gt$gt$14 = function(promise) {
      var $a, self = this;

      
      self.next['$<<'](promise);
      if ($truthy(self['$exception?']())) {
        promise.$reject(self.delayed['$[]'](0))
      } else if ($truthy(self['$resolved?']())) {
        promise.$resolve((function() {if ($truthy(self.delayed)) {
          return self.delayed['$[]'](0)
        } else {
          return self.$value()
        }; return nil; })())
      } else if ($truthy(self['$rejected?']())) {
        if ($truthy(($truthy($a = self.action['$key?']("failure")['$!']()) ? $a : $$($nesting, 'Promise')['$===']((function() {if ($truthy(self.delayed)) {
          return self.delayed['$[]'](0)
        } else {
          return self.error
        }; return nil; })())))) {
          promise.$reject((function() {if ($truthy(self.delayed)) {
            return self.delayed['$[]'](0)
          } else {
            return self.$error()
          }; return nil; })())
        } else if ($truthy(promise.$action()['$include?']("always"))) {
          promise.$reject((function() {if ($truthy(self.delayed)) {
            return self.delayed['$[]'](0)
          } else {
            return self.$error()
          }; return nil; })())}};
      return self;
    }, $Promise_$gt$gt$14.$$arity = 1);
    
    Opal.def(self, '$resolve', $Promise_resolve$15 = function $$resolve(value) {
      var $a, self = this, block = nil, e = nil;

      
      
      if (value == null) {
        value = nil;
      };
      if ($truthy(self['$realized?']())) {
        self.$raise($$($nesting, 'ArgumentError'), "the promise has already been realized")};
      if ($truthy($$($nesting, 'Promise')['$==='](value))) {
        return value['$<<'](self.prev)['$^'](self)};
      
      try {
        
        block = ($truthy($a = self.action['$[]']("success")) ? $a : self.action['$[]']("always"));
        if ($truthy(block)) {
          value = block.$call(value)};
        self['$resolve!'](value);
      } catch ($err) {
        if (Opal.rescue($err, [$$($nesting, 'Exception')])) {e = $err;
          try {
            self['$exception!'](e)
          } finally { Opal.pop_exception() }
        } else { throw $err; }
      };;
      return self;
    }, $Promise_resolve$15.$$arity = -1);
    
    Opal.def(self, '$resolve!', $Promise_resolve$excl$16 = function(value) {
      var $$17, self = this;

      
      self.realized = "resolve";
      self.value = value;
      if ($truthy(self.next['$any?']())) {
        return $send(self.next, 'each', [], ($$17 = function(p){var self = $$17.$$s || this;

        
          
          if (p == null) {
            p = nil;
          };
          return p.$resolve(value);}, $$17.$$s = self, $$17.$$arity = 1, $$17))
      } else {
        return (self.delayed = [value])
      };
    }, $Promise_resolve$excl$16.$$arity = 1);
    
    Opal.def(self, '$reject', $Promise_reject$18 = function $$reject(value) {
      var $a, self = this, block = nil, e = nil;

      
      
      if (value == null) {
        value = nil;
      };
      if ($truthy(self['$realized?']())) {
        self.$raise($$($nesting, 'ArgumentError'), "the promise has already been realized")};
      if ($truthy($$($nesting, 'Promise')['$==='](value))) {
        return value['$<<'](self.prev)['$^'](self)};
      
      try {
        
        block = ($truthy($a = self.action['$[]']("failure")) ? $a : self.action['$[]']("always"));
        if ($truthy(block)) {
          value = block.$call(value)};
        if ($truthy(self.action['$key?']("always"))) {
          self['$resolve!'](value)
        } else {
          self['$reject!'](value)
        };
      } catch ($err) {
        if (Opal.rescue($err, [$$($nesting, 'Exception')])) {e = $err;
          try {
            self['$exception!'](e)
          } finally { Opal.pop_exception() }
        } else { throw $err; }
      };;
      return self;
    }, $Promise_reject$18.$$arity = -1);
    
    Opal.def(self, '$reject!', $Promise_reject$excl$19 = function(value) {
      var $$20, self = this;

      
      self.realized = "reject";
      self.error = value;
      if ($truthy(self.next['$any?']())) {
        return $send(self.next, 'each', [], ($$20 = function(p){var self = $$20.$$s || this;

        
          
          if (p == null) {
            p = nil;
          };
          return p.$reject(value);}, $$20.$$s = self, $$20.$$arity = 1, $$20))
      } else {
        return (self.delayed = [value])
      };
    }, $Promise_reject$excl$19.$$arity = 1);
    
    Opal.def(self, '$exception!', $Promise_exception$excl$21 = function(error) {
      var self = this;

      
      self.exception = true;
      return self['$reject!'](error);
    }, $Promise_exception$excl$21.$$arity = 1);
    
    Opal.def(self, '$then', $Promise_then$22 = function $$then() {
      var $iter = $Promise_then$22.$$p, block = $iter || nil, self = this;

      if ($iter) $Promise_then$22.$$p = null;
      
      
      if ($iter) $Promise_then$22.$$p = null;;
      return self['$^']($$($nesting, 'Promise').$new($hash2(["success"], {"success": block})));
    }, $Promise_then$22.$$arity = 0);
    
    Opal.def(self, '$then!', $Promise_then$excl$23 = function() {
      var $iter = $Promise_then$excl$23.$$p, block = $iter || nil, self = this;

      if ($iter) $Promise_then$excl$23.$$p = null;
      
      
      if ($iter) $Promise_then$excl$23.$$p = null;;
      self['$there_can_be_only_one!']();
      return $send(self, 'then', [], block.$to_proc());
    }, $Promise_then$excl$23.$$arity = 0);
    Opal.alias(self, "do", "then");
    Opal.alias(self, "do!", "then!");
    
    Opal.def(self, '$fail', $Promise_fail$24 = function $$fail() {
      var $iter = $Promise_fail$24.$$p, block = $iter || nil, self = this;

      if ($iter) $Promise_fail$24.$$p = null;
      
      
      if ($iter) $Promise_fail$24.$$p = null;;
      return self['$^']($$($nesting, 'Promise').$new($hash2(["failure"], {"failure": block})));
    }, $Promise_fail$24.$$arity = 0);
    
    Opal.def(self, '$fail!', $Promise_fail$excl$25 = function() {
      var $iter = $Promise_fail$excl$25.$$p, block = $iter || nil, self = this;

      if ($iter) $Promise_fail$excl$25.$$p = null;
      
      
      if ($iter) $Promise_fail$excl$25.$$p = null;;
      self['$there_can_be_only_one!']();
      return $send(self, 'fail', [], block.$to_proc());
    }, $Promise_fail$excl$25.$$arity = 0);
    Opal.alias(self, "rescue", "fail");
    Opal.alias(self, "catch", "fail");
    Opal.alias(self, "rescue!", "fail!");
    Opal.alias(self, "catch!", "fail!");
    
    Opal.def(self, '$always', $Promise_always$26 = function $$always() {
      var $iter = $Promise_always$26.$$p, block = $iter || nil, self = this;

      if ($iter) $Promise_always$26.$$p = null;
      
      
      if ($iter) $Promise_always$26.$$p = null;;
      return self['$^']($$($nesting, 'Promise').$new($hash2(["always"], {"always": block})));
    }, $Promise_always$26.$$arity = 0);
    
    Opal.def(self, '$always!', $Promise_always$excl$27 = function() {
      var $iter = $Promise_always$excl$27.$$p, block = $iter || nil, self = this;

      if ($iter) $Promise_always$excl$27.$$p = null;
      
      
      if ($iter) $Promise_always$excl$27.$$p = null;;
      self['$there_can_be_only_one!']();
      return $send(self, 'always', [], block.$to_proc());
    }, $Promise_always$excl$27.$$arity = 0);
    Opal.alias(self, "finally", "always");
    Opal.alias(self, "ensure", "always");
    Opal.alias(self, "finally!", "always!");
    Opal.alias(self, "ensure!", "always!");
    
    Opal.def(self, '$trace', $Promise_trace$28 = function $$trace(depth) {
      var $iter = $Promise_trace$28.$$p, block = $iter || nil, self = this;

      if ($iter) $Promise_trace$28.$$p = null;
      
      
      if ($iter) $Promise_trace$28.$$p = null;;
      
      if (depth == null) {
        depth = nil;
      };
      return self['$^']($$($nesting, 'Trace').$new(depth, block));
    }, $Promise_trace$28.$$arity = -1);
    
    Opal.def(self, '$trace!', $Promise_trace$excl$29 = function($a) {
      var $iter = $Promise_trace$excl$29.$$p, block = $iter || nil, $post_args, args, self = this;

      if ($iter) $Promise_trace$excl$29.$$p = null;
      
      
      if ($iter) $Promise_trace$excl$29.$$p = null;;
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      
      args = $post_args;;
      self['$there_can_be_only_one!']();
      return $send(self, 'trace', Opal.to_a(args), block.$to_proc());
    }, $Promise_trace$excl$29.$$arity = -1);
    
    Opal.def(self, '$there_can_be_only_one!', $Promise_there_can_be_only_one$excl$30 = function() {
      var self = this;

      if ($truthy(self.next['$any?']())) {
        return self.$raise($$($nesting, 'ArgumentError'), "a promise has already been chained")
      } else {
        return nil
      }
    }, $Promise_there_can_be_only_one$excl$30.$$arity = 0);
    
    Opal.def(self, '$inspect', $Promise_inspect$31 = function $$inspect() {
      var $a, self = this, result = nil;

      
      result = "" + "#<" + (self.$class()) + "(" + (self.$object_id()) + ")";
      if ($truthy(self.next['$any?']())) {
        result = $rb_plus(result, "" + " >> " + (self.next.$inspect()))};
      result = $rb_plus(result, (function() {if ($truthy(self['$realized?']())) {
        return "" + ": " + (($truthy($a = self.value) ? $a : self.error).$inspect()) + ">"
      } else {
        return ">"
      }; return nil; })());
      return result;
    }, $Promise_inspect$31.$$arity = 0);
    (function($base, $super, $parent_nesting) {
      var self = $klass($base, $super, 'Trace');

      var $nesting = [self].concat($parent_nesting), $Trace_it$32, $Trace_initialize$33;

      
      Opal.defs(self, '$it', $Trace_it$32 = function $$it(promise) {
        var $a, self = this, current = nil, prev = nil;

        
        current = [];
        if ($truthy(($truthy($a = promise['$act?']()) ? $a : promise.$prev()['$nil?']()))) {
          current.$push(promise.$value())};
        prev = promise.$prev();
        if ($truthy(prev)) {
          return current.$concat(self.$it(prev))
        } else {
          return current
        };
      }, $Trace_it$32.$$arity = 1);
      return (Opal.def(self, '$initialize', $Trace_initialize$33 = function $$initialize(depth, block) {
        var $$34, $iter = $Trace_initialize$33.$$p, $yield = $iter || nil, self = this;

        if ($iter) $Trace_initialize$33.$$p = null;
        
        self.depth = depth;
        return $send(self, Opal.find_super_dispatcher(self, 'initialize', $Trace_initialize$33, false), [$hash2(["success"], {"success": $send(self, 'proc', [], ($$34 = function(){var self = $$34.$$s || this, $a, trace = nil;

        
          trace = $$($nesting, 'Trace').$it(self).$reverse();
          trace.$pop();
          if ($truthy(($truthy($a = depth) ? $rb_le(depth, trace.$length()) : $a))) {
            trace.$shift($rb_minus(trace.$length(), depth))};
          return $send(block, 'call', Opal.to_a(trace));}, $$34.$$s = self, $$34.$$arity = 0, $$34))})], null);
      }, $Trace_initialize$33.$$arity = 2), nil) && 'initialize';
    })($nesting[0], self, $nesting);
    return (function($base, $super, $parent_nesting) {
      var self = $klass($base, $super, 'When');

      var $nesting = [self].concat($parent_nesting), $When_initialize$35, $When_each$37, $When_collect$39, $When_inject$41, $When_wait$43, $When_$gt$gt$45, $When_try$47;

      self.$$prototype.wait = nil;
      
      
      Opal.def(self, '$initialize', $When_initialize$35 = function $$initialize(promises) {
        var $$36, $iter = $When_initialize$35.$$p, $yield = $iter || nil, self = this;

        if ($iter) $When_initialize$35.$$p = null;
        
        
        if (promises == null) {
          promises = [];
        };
        $send(self, Opal.find_super_dispatcher(self, 'initialize', $When_initialize$35, false), [], null);
        self.wait = [];
        return $send(promises, 'each', [], ($$36 = function(promise){var self = $$36.$$s || this;

        
          
          if (promise == null) {
            promise = nil;
          };
          return self.$wait(promise);}, $$36.$$s = self, $$36.$$arity = 1, $$36));
      }, $When_initialize$35.$$arity = -1);
      
      Opal.def(self, '$each', $When_each$37 = function $$each() {
        var $iter = $When_each$37.$$p, block = $iter || nil, $$38, self = this;

        if ($iter) $When_each$37.$$p = null;
        
        
        if ($iter) $When_each$37.$$p = null;;
        if ($truthy(block)) {
        } else {
          self.$raise($$($nesting, 'ArgumentError'), "no block given")
        };
        return $send(self, 'then', [], ($$38 = function(values){var self = $$38.$$s || this;

        
          
          if (values == null) {
            values = nil;
          };
          return $send(values, 'each', [], block.$to_proc());}, $$38.$$s = self, $$38.$$arity = 1, $$38));
      }, $When_each$37.$$arity = 0);
      
      Opal.def(self, '$collect', $When_collect$39 = function $$collect() {
        var $iter = $When_collect$39.$$p, block = $iter || nil, $$40, self = this;

        if ($iter) $When_collect$39.$$p = null;
        
        
        if ($iter) $When_collect$39.$$p = null;;
        if ($truthy(block)) {
        } else {
          self.$raise($$($nesting, 'ArgumentError'), "no block given")
        };
        return $send(self, 'then', [], ($$40 = function(values){var self = $$40.$$s || this;

        
          
          if (values == null) {
            values = nil;
          };
          return $$($nesting, 'When').$new($send(values, 'map', [], block.$to_proc()));}, $$40.$$s = self, $$40.$$arity = 1, $$40));
      }, $When_collect$39.$$arity = 0);
      
      Opal.def(self, '$inject', $When_inject$41 = function $$inject($a) {
        var $iter = $When_inject$41.$$p, block = $iter || nil, $post_args, args, $$42, self = this;

        if ($iter) $When_inject$41.$$p = null;
        
        
        if ($iter) $When_inject$41.$$p = null;;
        
        $post_args = Opal.slice.call(arguments, 0, arguments.length);
        
        args = $post_args;;
        return $send(self, 'then', [], ($$42 = function(values){var self = $$42.$$s || this;

        
          
          if (values == null) {
            values = nil;
          };
          return $send(values, 'reduce', Opal.to_a(args), block.$to_proc());}, $$42.$$s = self, $$42.$$arity = 1, $$42));
      }, $When_inject$41.$$arity = -1);
      Opal.alias(self, "map", "collect");
      Opal.alias(self, "reduce", "inject");
      
      Opal.def(self, '$wait', $When_wait$43 = function $$wait(promise) {
        var $$44, self = this;

        
        if ($truthy($$($nesting, 'Promise')['$==='](promise))) {
        } else {
          promise = $$($nesting, 'Promise').$value(promise)
        };
        if ($truthy(promise['$act?']())) {
          promise = promise.$then()};
        self.wait['$<<'](promise);
        $send(promise, 'always', [], ($$44 = function(){var self = $$44.$$s || this;
          if (self.next == null) self.next = nil;

        if ($truthy(self.next['$any?']())) {
            return self.$try()
          } else {
            return nil
          }}, $$44.$$s = self, $$44.$$arity = 0, $$44));
        return self;
      }, $When_wait$43.$$arity = 1);
      Opal.alias(self, "and", "wait");
      
      Opal.def(self, '$>>', $When_$gt$gt$45 = function($a) {
        var $post_args, $$46, $iter = $When_$gt$gt$45.$$p, $yield = $iter || nil, self = this, $zuper = nil, $zuper_i = nil, $zuper_ii = nil;

        if ($iter) $When_$gt$gt$45.$$p = null;
        // Prepare super implicit arguments
        for($zuper_i = 0, $zuper_ii = arguments.length, $zuper = new Array($zuper_ii); $zuper_i < $zuper_ii; $zuper_i++) {
          $zuper[$zuper_i] = arguments[$zuper_i];
        }
        
        
        $post_args = Opal.slice.call(arguments, 0, arguments.length);
        ;
        return $send($send(self, Opal.find_super_dispatcher(self, '>>', $When_$gt$gt$45, false), $zuper, $iter), 'tap', [], ($$46 = function(){var self = $$46.$$s || this;

        return self.$try()}, $$46.$$s = self, $$46.$$arity = 0, $$46));
      }, $When_$gt$gt$45.$$arity = -1);
      return (Opal.def(self, '$try', $When_try$47 = function() {
        var self = this, promise = nil;

        if ($truthy($send(self.wait, 'all?', [], "realized?".$to_proc()))) {
          
          promise = $send(self.wait, 'find', [], "rejected?".$to_proc());
          if ($truthy(promise)) {
            return self.$reject(promise.$error())
          } else {
            return self.$resolve($send(self.wait, 'map', [], "value".$to_proc()))
          };
        } else {
          return nil
        }
      }, $When_try$47.$$arity = 0), nil) && 'try';
    })($nesting[0], self, $nesting);
  })($nesting[0], null, $nesting)
};
